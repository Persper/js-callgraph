'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _util = require('./util');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VueSSRServerPlugin = function () {
  function VueSSRServerPlugin() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, VueSSRServerPlugin);

    this.options = Object.assign({
      filename: 'vue-ssr-server-bundle.json'
    }, options);
  }

  _createClass(VueSSRServerPlugin, [{
    key: 'apply',
    value: function apply(compiler) {
      var _this = this;

      (0, _util.validate)(compiler);

      compiler.plugin('emit', function (compilation, cb) {
        var stats = compilation.getStats().toJson();
        var entryName = Object.keys(stats.entrypoints)[0];
        var entryInfo = stats.entrypoints[entryName];

        if (!entryInfo) {
          // #5553
          return cb();
        }

        var entryAssets = entryInfo.assets.filter(_util.isJS);

        if (entryAssets.length > 1) {
          throw new Error('Server-side bundle should have one single entry file. ' + 'Avoid using CommonsChunkPlugin in the server config.');
        }

        var entry = entryAssets[0];
        if (!entry || typeof entry !== 'string') {
          throw new Error('Entry "' + entryName + '" not found. Did you specify the correct entry option?');
        }

        var bundle = {
          entry: entry,
          files: {},
          maps: {}
        };

        stats.assets.forEach(function (asset) {
          if (asset.name.match(/\.js$/)) {
            bundle.files[asset.name] = compilation.assets[asset.name].source();
          } else if (asset.name.match(/\.js\.map$/)) {
            bundle.maps[asset.name.replace(/\.map$/, '')] = JSON.parse(compilation.assets[asset.name].source());
          }
          // do not emit anything else for server
          delete compilation.assets[asset.name];
        });

        var json = JSON.stringify(bundle, null, 2);
        var filename = _this.options.filename;

        compilation.assets[filename] = {
          source: function source() {
            return json;
          },
          size: function size() {
            return json.length;
          }
        };

        cb();
      });
    }
  }]);

  return VueSSRServerPlugin;
}();

exports.default = VueSSRServerPlugin;


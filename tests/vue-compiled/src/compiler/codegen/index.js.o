'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CodegenState = undefined;
exports.generate = generate;
exports.genElement = genElement;
exports.genIf = genIf;
exports.genFor = genFor;
exports.genData = genData;
exports.genChildren = genChildren;
exports.genText = genText;
exports.genComment = genComment;

var _events = require('./events');

var _index = require('../directives/index');

var _index2 = _interopRequireDefault(_index);

var _util = require('shared/util');

var _helpers = require('../helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CodegenState = exports.CodegenState = function CodegenState(options) {
  _classCallCheck(this, CodegenState);

  this.options = options;
  this.warn = options.warn || _helpers.baseWarn;
  this.transforms = (0, _helpers.pluckModuleFunction)(options.modules, 'transformCode');
  this.dataGenFns = (0, _helpers.pluckModuleFunction)(options.modules, 'genData');
  this.directives = (0, _util.extend)((0, _util.extend)({}, _index2.default), options.directives);
  var isReservedTag = options.isReservedTag || _util.no;
  this.maybeComponent = function (el) {
    return !isReservedTag(el.tag);
  };
  this.onceId = 0;
  this.staticRenderFns = [];
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: 'with(this){return ' + code + '}',
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var _code = void 0;
    if (el.component) {
      _code = genComponent(el.component, el, state);
    } else {
      var data = el.plain ? undefined : genData(el, state);

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      _code = '_c(\'' + el.tag + '\'' + (data ? ',' + data : '' // data
      ) + (children ? ',' + children : '' // children
      ) + ')';
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      _code = state.transforms[i](el, _code);
    }
    return _code;
  }
}

// hoist static sub-trees out
function genStatic(el, state) {
  el.staticProcessed = true;
  state.staticRenderFns.push('with(this){return ' + genElement(el, state) + '}');
  return '_m(' + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ')';
}

// v-once
function genOnce(el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var _key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        _key = parent.key;
        break;
      }
      parent = parent.parent;
    }
    if (!_key) {
      process.env.NODE_ENV !== 'production' && state.warn('v-once can only be used inside v-for that is keyed. ');
      return genElement(el, state);
    }
    return '_o(' + genElement(el, state) + ',' + state.onceId++ + ',' + _key + ')';
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return '(' + condition.exp + ')?' + genTernaryExp(condition.block) + ':' + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return '' + genTernaryExp(condition.block);
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ',' + el.iterator1 : '';
  var iterator2 = el.iterator2 ? ',' + el.iterator2 : '';

  if (process.env.NODE_ENV !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn('<' + el.tag + ' v-for="' + alias + ' in ' + exp + '">: component lists rendered with ' + 'v-for should have explicit keys. ' + 'See https://vuejs.org/guide/list.html#key for more info.', true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + '((' + exp + '),' + ('function(' + alias + iterator1 + iterator2 + '){') + ('return ' + (altGen || genElement)(el, state)) + '})';
}

function genData(el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) data += dirs + ',';

  // key
  if (el.key) {
    data += 'key:' + el.key + ',';
  }
  // ref
  if (el.ref) {
    data += 'ref:' + el.ref + ',';
  }
  if (el.refInFor) {
    data += 'refInFor:true,';
  }
  // pre
  if (el.pre) {
    data += 'pre:true,';
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += 'tag:"' + el.tag + '",';
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += 'attrs:{' + genProps(el.attrs) + '},';
  }
  // DOM props
  if (el.props) {
    data += 'domProps:{' + genProps(el.props) + '},';
  }
  // event handlers
  if (el.events) {
    data += (0, _events.genHandlers)(el.events, false, state.warn) + ',';
  }
  if (el.nativeEvents) {
    data += (0, _events.genHandlers)(el.nativeEvents, true, state.warn) + ',';
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += 'slot:' + el.slotTarget + ',';
  }
  // scoped slots
  if (el.scopedSlots) {
    data += genScopedSlots(el.scopedSlots, state) + ',';
  }
  // component v-model
  if (el.model) {
    data += 'model:{value:' + el.model.value + ',callback:' + el.model.callback + ',expression:' + el.model.expression + '},';
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ',';
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;
  if (!dirs) return;
  var res = 'directives:[';
  var hasRuntime = false;
  var i = void 0,
      l = void 0,
      dir = void 0,
      needRuntime = void 0;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += '{name:"' + dir.name + '",rawName:"' + dir.rawName + '"' + (dir.value ? ',value:(' + dir.value + '),expression:' + JSON.stringify(dir.value) : '') + (dir.arg ? ',arg:"' + dir.arg + '"' : '') + (dir.modifiers ? ',modifiers:' + JSON.stringify(dir.modifiers) : '') + '},';
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];
  if (process.env.NODE_ENV !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {
    state.warn('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return 'inlineTemplate:{render:function(){' + inlineRenderFns.render + '},staticRenderFns:[' + inlineRenderFns.staticRenderFns.map(function (code) {
      return 'function(){' + code + '}';
    }).join(',') + ']}';
  }
}

function genScopedSlots(slots, state) {
  return 'scopedSlots:_u([' + Object.keys(slots).map(function (key) {
    return genScopedSlot(key, slots[key], state);
  }).join(',') + '])';
}

function genScopedSlot(key, el, state) {
  if (el.for && !el.forProcessed) {
    return genForScopedSlot(key, el, state);
  }
  var fn = 'function(' + String(el.slotScope) + '){' + ('return ' + (el.tag === 'template' ? el.if ? el.if + '?' + (genChildren(el, state) || 'undefined') + ':undefined' : genChildren(el, state) || 'undefined' : genElement(el, state)) + '}');
  return '{key:' + key + ',fn:' + fn + '}';
}

function genForScopedSlot(key, el, state) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ',' + el.iterator1 : '';
  var iterator2 = el.iterator2 ? ',' + el.iterator2 : '';
  el.forProcessed = true; // avoid recursion
  return '_l((' + exp + '),' + ('function(' + alias + iterator1 + iterator2 + '){') + ('return ' + genScopedSlot(key, el, state)) + '})';
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;
  if (children.length) {
    var _el = children[0];
    // optimize single v-for
    if (children.length === 1 && _el.for && _el.tag !== 'template' && _el.tag !== 'slot') {
      return (altGenElement || genElement)(_el, state);
    }
    var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return '[' + children.map(function (c) {
      return gen(c, state);
    }).join(',') + ']' + (normalizationType ? ',' + normalizationType : '');
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children, maybeComponent) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var _el2 = children[i];
    if (_el2.type !== 1) {
      continue;
    }
    if (needsNormalization(_el2) || _el2.ifConditions && _el2.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }
    if (maybeComponent(_el2) || _el2.ifConditions && _el2.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }
  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  }if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return '_v(' + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ')';
}

function genComment(comment) {
  return '_e(' + JSON.stringify(comment.text) + ')';
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = '_t(' + slotName + (children ? ',' + children : '');
  var attrs = el.attrs && '{' + el.attrs.map(function (a) {
    return (0, _util.camelize)(a.name) + ':' + a.value;
  }).join(',') + '}';
  var bind = el.attrsMap['v-bind'];
  if ((attrs || bind) && !children) {
    res += ',null';
  }
  if (attrs) {
    res += ',' + attrs;
  }
  if (bind) {
    res += (attrs ? '' : ',null') + ',' + bind;
  }
  return res + ')';
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return '_c(' + componentName + ',' + genData(el, state) + (children ? ',' + children : '') + ')';
}

function genProps(props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    /* istanbul ignore if */
    if (__WEEX__) {
      res += '"' + prop.name + '":' + generateValue(prop.value) + ',';
    } else {
      res += '"' + prop.name + '":' + transformSpecialNewlines(prop.value) + ',';
    }
  }
  return res.slice(0, -1);
}

/* istanbul ignore next */
function generateValue(value) {
  if (typeof value === 'string') {
    return transformSpecialNewlines(value);
  }
  return JSON.stringify(value);
}

// #3895, #4268
function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}


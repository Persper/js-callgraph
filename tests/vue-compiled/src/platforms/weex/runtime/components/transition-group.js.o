'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('core/util/index');

var _transition = require('./transition');

var props = (0, _index.extend)({
  tag: String,
  moveClass: String
}, _transition.transitionProps);

delete props.mode;

exports.default = {
  props: props,

  created: function created() {
    var dom = this.$requireWeexModule('dom');
    this.getPosition = function (el) {
      return new Promise(function (resolve, reject) {
        dom.getComponentRect(el.ref, function (res) {
          if (!res.result) {
            reject(new Error('failed to get rect for element: ' + el.tag));
          } else {
            resolve(res.size);
          }
        });
      });
    };

    var animation = this.$requireWeexModule('animation');
    this.animate = function (el, options) {
      return new Promise(function (resolve) {
        animation.transition(el.ref, options, resolve);
      });
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = (0, _transition.extractTransitionData)(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag : c.tag;
          (0, _index.warn)('<transition-group> children must be keyed: <' + name + '>');
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      prevChildren.forEach(function (c) {
        c.data.transition = transitionData;

        // TODO: record before patch positions

        if (map[c.key]) {
          kept.push(c);
        } else {
          removed.push(c);
        }
      });
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    var moveData = children.length && this.getMoveData(children[0].context, moveClass);
    if (!moveData) {
      return;
    }

    // TODO: finish implementing move animations once
    // we have access to sync getComponentRect()

    // children.forEach(callPendingCbs)

    // Promise.all(children.map(c => {
    //   const oldPos = c.data.pos
    //   const newPos = c.data.newPos
    //   const dx = oldPos.left - newPos.left
    //   const dy = oldPos.top - newPos.top
    //   if (dx || dy) {
    //     c.data.moved = true
    //     return this.animate(c.elm, {
    //       styles: {
    //         transform: `translate(${dx}px,${dy}px)`
    //       }
    //     })
    //   }
    // })).then(() => {
    //   children.forEach(c => {
    //     if (c.data.moved) {
    //       this.animate(c.elm, {
    //         styles: {
    //           transform: ''
    //         },
    //         duration: moveData.duration || 0,
    //         delay: moveData.delay || 0,
    //         timingFunction: moveData.timingFunction || 'linear'
    //       })
    //     }
    //   })
    // })
  },


  methods: {
    getMoveData: function getMoveData(context, moveClass) {
      var stylesheet = context.$options.style || {};
      return stylesheet['@TRANSITION'] && stylesheet['@TRANSITION'][moveClass];
    }
  }

  // function callPendingCbs (c) {
  //   /* istanbul ignore if */
  //   if (c.elm._moveCb) {
  //     c.elm._moveCb()
  //   }
  //   /* istanbul ignore if */
  //   if (c.elm._enterCb) {
  //     c.elm._enterCb()
  //   }
  // }

};

